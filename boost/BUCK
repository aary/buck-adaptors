def find_all_public_includes(header_map):
    """
    Workaround to the first argument in subdir_glob not accepting a pattern.
    Does the dirty work that subdir_glob would have been able to do with
    patterns manually
    """
    map_to_return = {}
    for key, value in header_map.iteritems():
        # remove the path until hit the "include" folder and keep things after
        # that, for example, convert "something/else/include/folder/header.hpp"
        # to "folder/header.hpp"
        array_of_path_with_include = key.strip("/").split('/')
        array_of_path_without_include = []
        for i in range(0, len(array_of_path_with_include)):
            # if found include then push everything after that to the path
            if array_of_path_with_include[i] == "include":
                for j in range(i + 1, len(array_of_path_with_include)):
                    array_of_path_without_include.append(\
                        array_of_path_with_include[j])
                break

        if array_of_path_without_include:
            new_key = "/".join(array_of_path_without_include)
            map_to_return[new_key] = value
    return map_to_return


cxx_library(
    name = "boost",

    exported_deps = [
        "//boost:boost_headers",
        "//boost:chrono",
        "//boost:context",
        "//boost:filesystem",
        "//boost:iostreams",
        "//boost:log",
        "//boost:program_options",
        "//boost:python",
        "//boost:regex",
        "//boost:serialization",
        "//boost:signals",
        "//boost:system",
        "//boost:thread",
        "//boost:timer",
        "//boost:wave",
    ],

    tests = [
        "//boost:test",
    ],

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "boost_headers",
    header_namespace = "",

    # exported_headers = find_all_public_includes(subdir_glob([
    #     ("boost/libs", "**/*.hpp"),
    #     ("boost/libs", "**/*.ipp"),
    #     ("boost/libs", "**/*.h"),
    # ])),
    exported_headers = subdir_glob([
        ("boost", "**/*.hpp"),
        ("boost", "**/*.h"),
        ("boost", "**/*.ipp"),
    ]),

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "chrono",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    srcs = glob([
        "boost/libs/chrono/src/**/*.cpp",
    ]),

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "context",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    srcs = glob([
        "boost/libs/context/src/**/*.cpp",
    ], excludes = [
        "boost/libs/context/src/windows/*.cpp",
        "boost/libs/context/src/unsupported.cpp",
        "boost/libs/context/src/untested.cpp",
    ]),

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "filesystem",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    srcs = glob([
        "boost/libs/filesystem/src/**/*.cpp",
    ]),

    # When compiling a Boost.Filesystem, there is a warning about comparing
    # the address of a reference (reference to a statically created variable
    # within a function) to boolean truth, this is done because the variable
    # is passed in as a pointer and the author thought it would be nice to
    # assert to make sure its always true.  The C++ compiler complains about
    # this as it is not needed, but it's not wrong; and it's not undefined
    # behavior, so suppress the warning
    compiler_flags = [
        "-Wno-undefined-bool-conversion",
    ],

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "iostreams",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
        "//zlib:zlib",
        "//bzip2:bzip2",
    ],
    srcs = glob([
        "boost/libs/iostreams/src/**/*.cpp",
    ]),

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "locale",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    srcs = glob([
        "boost/libs/locale/src/**/*.cpp",
    ], excludes = [
        "boost/libs/locale/src/win32/**/*.cpp",
    ]),

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "log",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    headers = subdir_glob([
        ("boost/libs/log/src", "**/*.hpp"),
    ]),
    srcs = glob([
        "boost/libs/log/src/**/*.cpp",
    ], excludes = [
        "boost/libs/log/src/windows/**/*.cpp",
        "boost/libs/log/src/dump_avx2.cpp",
    ]),

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "mpi",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    headers = subdir_glob([
        ("boost/libs/mpi/src", "**/*.hpp"),
    ]),
    srcs = glob([
        "boost/libs/mpi/src/**/*.cpp",
    ]),

    visibility = [
        "PUBLIC",
    ],
)


cxx_library(
    name = "program_options",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    srcs = glob([
        "boost/libs/program_options/src/*.cpp",
    ]),

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "python",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    headers = subdir_glob([
        ("python2.7", "**/*.h"),
    ]),
    srcs = glob([
        "boost/libs/python/src/*.cpp",
    ]),

    # There are lots of warnings generated by -Wparentheses-equality when
    # compiling Boost.Python, the official 1.63 release contains extra
    # parentheses around expressions.  Although this is well defined C++ code,
    # it generates ugly warnings, so suppress them
    compiler_flags = [
        "-Wno-parentheses-equality",
    ],

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "regex",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    srcs = glob([
        "boost/libs/regex/src/**/*.cpp",
    ]),

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "serialization",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    srcs = glob([
        "boost/libs/serialization/src/**/*.cpp",
    ]),

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "signals",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    srcs = glob([
        "boost/libs/signals/src/**/*.cpp",
    ]),

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "system",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    srcs = glob([
        "boost/libs/system/src/**/*.cpp",
    ]),

    visibility = [
        "PUBLIC",
    ],
)


cxx_library(
    name = "thread",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    srcs = glob([
        "boost/libs/thread/src/**/*.cpp",
    ], excludes = [
        "boost/libs/thread/src/win32/**/*.cpp",
    ]),

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "timer",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    srcs = glob([
        "boost/libs/timer/src/**/*.cpp",
    ]),

    visibility = [
        "PUBLIC",
    ],
)

cxx_library(
    name = "wave",
    header_namespace = "",
    deps = [
        "//boost:boost_headers",
    ],
    srcs = glob([
        "boost/libs/wave/src/**/*.cpp",
    ]),

    # There are lots of warnings generated by -Wparentheses-equality when
    # compiling Boost.Wave, the official 1.63 release contains extra
    # parentheses around expressions.  Although this is well defined C++ code,
    # it generates ugly warnings, so suppress them
    compiler_flags = [
        "-Wno-parentheses-equality",
    ],

    visibility = [
        "PUBLIC",
    ],
)

cxx_test(
    name = "test",
    srcs = [
        "test.cpp",
    ],
    deps = [
        "//boost:boost",
    ],
)
