def find_all_public_includes(map_public_private_paths):
    ret_dict = {}
    for key in map_public_private_paths:
        public_path = map_public_private_paths[key]

        # reverse the string, find the first occurence of the "include" string
        # from the back, remove everything after the string and then reverse it
        # back
        public_path = public_path[::-1]
        pos_include = public_path.find("include/"[::-1])
        if pos_include == -1:
            continue

        # truncate the string to the beginning of the first slash after the
        # include
        public_path = public_path[:pos_include]
        public_path = public_path[::-1]

        # add the key value pair to the dictionary
        ret_dict[public_path.strip("/")] = map_public_private_paths[key]

    return ret_dict

cxx_library(
    name = "boost",
    header_namespace = "",

    # No sources will be included because boost has deprecated most of the
    # source files that it had earlier.  It is almost exlusively a header only
    # module now.  yay.
    #
    # srcs = glob(["**/*.cpp"]),
    exported_headers = find_all_public_includes(subdir_glob([
        ("boost/libs", "**/*.hpp"),
        ("boost/libs", "**/*.ipp"),
        ("boost/libs", "**/*.h"),
    ])),

    visibility = [
        "PUBLIC",
    ],
)
